<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | 姚翔的部落格]]></title>
  <link href="http://sherlockyao.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://sherlockyao.com/"/>
  <updated>2015-06-28T16:50:11+08:00</updated>
  <id>http://sherlockyao.com/</id>
  <author>
    <name><![CDATA[Sherlock Yao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Content Hugging vs. Compression Resistance]]></title>
    <link href="http://sherlockyao.com/blog/2015/04/18/hugging-vs-resistance/"/>
    <updated>2015-04-18T16:32:00+08:00</updated>
    <id>http://sherlockyao.com/blog/2015/04/18/hugging-vs-resistance</id>
    <content type="html"><![CDATA[<p>iOS Auto Layout中的Content Hugging（内容吸附）和Compression Resistance（压缩阻力）曾一度让我非常困惑，看过一些说明的文章后当时觉得豁然开朗，但一段时间后便又忘记了，所以我决定再一次全面地整理一下并用博客的形式分享出去，这样可以帮助我自己加强记忆。
(注：“内容吸附”和“压缩阻力”是特别借用了objccn里文章的翻译内容，非常感谢作者，<a href="http://objccn.io/issue-3-5/">原文链接</a>)</p>

<p>首先，我们先简单说明一下约束（Constraint）中的Priority概念：Auto Layout中，每个约束都有一个1-1000的priority值，其中1000是其默认的值，也是 NSLayoutPriorityRequired 的，意思就是这个约束必须完全得到满足；所有小于1000的值则都是非强制的。系统在实现自动布局时，首先会满足所有priority是1000的约束，然后按照从大到小的值依次去尽量满足非强制性的约束，这种情况下，系统会尽量使结果的值接近于约束要求的值。</p>

<p>现在让我们来具体说明一下Hugging和Resistance到底是什么，用通俗易懂的话来描述的话是这样的：</p>

<ul>
<li>Content Hugging：我的内容区域不想被扩展（变高或变宽）</li>
<li>Compression Resistance：我的内容区域不想被压缩 （变矮或变短）</li>
</ul>


<p>注意到了吧，描述里面都有“内容区域”这个概念，这个指的就是Intrinsic Content Size，所以压缩阻力和内容吸附只对定义了Intrinsic Content Size的UI元素有效，否则的话就不存在所谓的“我的内容区域”的概念了。</p>

<p>下面就以一个具体的例子来说明一下这两个属性的作用。假设我们有一个Button放置在界面中，同时设置了两个priority是500的约束：左右各距离父元素 30 points，即如下图所示：</p>

<blockquote><p>|-30-[     Button     ]-30-|</p></blockquote>

<p>此时，如果我们给它设置一个水平priority是750的 Content Hugging 属性，那我们将看到它的实际布局会变成这样：</p>

<blockquote><p>|&mdash;&mdash;60&mdash;&ndash;[Button]&mdash;-60&mdash;&mdash;|</p></blockquote>

<p>但是如果这个 Content Hugging 属性的priority是小于500的，那我们看到的效果和初始状态是一样的：</p>

<blockquote><p>|-30-[     Button     ]-30-|</p></blockquote>

<p>然后，因为某些原因，它的父元素的宽度变窄了，在没有任何 Compression Resistance 属性时，它就变成了这样（按钮的文字显示不全了）：</p>

<blockquote><p>|-30-[But..]-30-|</p></blockquote>

<p>此时，如果我们给它设置一个水平priority是750的 Compression Resistance 属性，结果就会是：</p>

<blockquote><p>|-25-[Button]-25-|</p></blockquote>

<p>同样的，如果这个属性的优先级小于500，那结果就没有变化。另外，如果我们把初始的两个左右边距的约束优先级调整到1000，那不管我们怎么设置压缩阻力或内容吸附的属性，都不会改变布局效果，这个按钮会始终保持左右边距30的布局。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS的UI并发处理方案]]></title>
    <link href="http://sherlockyao.com/blog/2015/04/17/no-blocking-ui-cell-update/"/>
    <updated>2015-04-17T14:36:00+08:00</updated>
    <id>http://sherlockyao.com/blog/2015/04/17/no-blocking-ui-cell-update</id>
    <content type="html"><![CDATA[<p>让用户体验更流畅是大部分应用必须要考虑的方面，我们知道iOS应用中所有UI相关的更新操作必须在主线程中进行，所以一个提升应用流畅性的大原则便是：尽量把那些耗时多，但不与UI更新直接相关的工作移出主线程。以下我将用一个比较常见的TableView Cell更新的例子来展示一下处理UI并发的几个最佳实践。我们的目标是让应用能在处理大量运算的同时，又能及时响应用户的交互以及界面上的事件。</p>

<p>假设我们有一个列表界面，每一行需要显示一个店铺的信息，通常的方案便是Subclass一个TableViewCell，然后提供自定义的方法接收店铺信息数据，并更新到UI上，大致代码如下：</p>

<p>```objc</p>

<h1>StoreInfoCell : UITableViewCell</h1>

<p>@implementation StoreInfoCell</p>

<ul>
<li>(void)displayStoreInfo:(StoreInfo *)storeInfo {
  self.titleLabel.text = storeInfo.title;
self.addressLabel.text = storeInfo.address;
}</li>
</ul>


<p>@end</p>

<p>```</p>

<p>需求变化是软件开发的常态，不久PM便会说，在原有的店铺信息中，现在又增加了这个店铺过去七天的客流数据，于是要求应用能在Cell中多显示一个柱状图来表示这个客流数据。我们先来实现这个功能：</p>

<p>```objc</p>

<ul>
<li>(void)displayStoreInfo:(StoreInfo *)storeInfo {
  self.titleLabel.text = storeInfo.title;
self.addressLabel.text = storeInfo.address;
self.histogramImageView.image = [HistogramTool generateImageForTrafficData:storeInfo.trafficData];
}</li>
</ul>


<p>```</p>

<p>功能已经实现，但是因为HistogramTool这个工具去生成柱状图耗时相当久，我们在运行应用测试时会发现滚动列表界面时有严重的卡顿。接下来我们就来进行优化，显而易见是generateImageForTrafficData这个方法阻塞了主线程从而造成卡顿，我们可以把它移到其他线程中去处理，这里我们采用GCD来实现这个方案：</p>

<p>```objc</p>

<ul>
<li><p>(void)displayStoreInfo:(StoreInfo *)storeInfo {
  self.titleLabel.text = storeInfo.title;
self.addressLabel.text = storeInfo.address;
self.histogramImageView.image = nil;</p>

<p>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
      UIImage *histogramImage = [HistogramTool generateImageForTrafficData:storeInfo.trafficData];
      dispatch_async(dispatch_get_main_queue(), ^{
          self.histogramImageView.image = histogramImage;
      });
  });
}</p></li>
</ul>


<p>```</p>

<p>经过上面的改进后，我们将看到页面的滚动变得流畅了，但是会发现页面有闪烁的现象，Cell上的柱状图会出现自我切换的问题，同时数据似乎会不匹配，这是为什么呢？原因就在于Reuse Cell，为了提升性能，所有TableView中的Cell都是从它的Reuse Pool中获取来的，所以当快速滚动列表时，新出现的Cell实例其实是一些已经移出界面可视范围被回收了的老Cell实例，但它们被回收时并没有取消异步生成柱状图的过程，所以当它们生成完后会又更新到界面上，这就会造成第7行的Cell显示出了第1行店铺的柱状图，然后过了一会儿又更新成了第7行店铺自己的柱状图。为了解决信息不匹配的问题，我们可以在更新前做一个check：</p>

<p>```objc</p>

<ul>
<li><p>(void)displayStoreInfo:(StoreInfo *)storeInfo {
  self.titleLabel.text = storeInfo.title;
self.addressLabel.text = storeInfo.address;
self.histogramImageView.image = nil;</p>

<p>  self.trafficData = storeInfo.trafficData;
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
  TrafficData <em>data = storeInfo.trafficData;
      UIImage </em>histogramImage = [HistogramTool generateImageForTrafficData:data];
      dispatch_async(dispatch_get_main_queue(), ^{
          if (data.id == self.trafficData.id) {
              self.histogramImageView.image = histogramImage;
          }
      });
  });
}</p></li>
</ul>


<p>```</p>

<p>这样虽然解决了信息不匹配的问题，但却还是消耗了很多不必要的计算资源，因为当cell被移出屏幕后，对应cell的柱状图计算过程仍然还在queue中，我们应该取消它们，于是我们引入NSOperationQueue来进一步优化：</p>

<p>```objc</p>

<ul>
<li><p>(void)displayStoreInfo:(StoreInfo *)storeInfo {
  self.titleLabel.text = storeInfo.title;
self.addressLabel.text = storeInfo.address;
self.histogramImageView.image = nil;</p>

<p>  self.trafficData = storeInfo.trafficData;
  [self.queue cancelAllOperations];
[self asyncDisplayHistogramImage];
}</p></li>
<li><p>(void)asyncDisplayHistogramImage {
  NSBlockOperation <em>operation = [NSBlockOperation new];
__weak NSBlockOperation </em>weakOperation = operation;
[operation addExecutionBlock:^{
  if ([weakOperation isCancelled]) {
    return;
  }
  TrafficData <em>data = storeInfo.trafficData;
  UIImage </em>histogramImage = [HistogramTool generateImageForTrafficData:data];
  if (![weakOperation isCancelled] &amp;&amp; data.id == self.trafficData.id) {
    dispatch_async(dispatch_get_main_queue(), ^{
      self.histogramImageView.image = histogramImage;
    });
  }
}];
[self.queue addOperation:operation];
}</p></li>
</ul>


<p>```</p>

<p>好了，现在我们有了取消计算的机制，但是如果用Time Profiler工具去查看应用运行情况时会发现，当快速滚动列表时，还是有一些时间浪费在不必要的计算上，这是因为在调用generateImageForTrafficData这个方法前并没有等待时间，当一个cell被显示在页面上时，它便已经开始了这个计算过程，而因为快速滚动的缘故它又被移出了界面，所以这个计算过程其实是浪费了的。所以我们可以加上一些等待时间来继续优化：</p>

<p>```objc</p>

<ul>
<li><p>(void)displayStoreInfo:(StoreInfo *)storeInfo {
  self.titleLabel.text = storeInfo.title;
self.addressLabel.text = storeInfo.address;
self.histogramImageView.image = nil;</p>

<p>  self.trafficData = storeInfo.trafficData;
  [self cancelPreviousOperations];
  [self performSelector:@selector(asyncDisplayHistogramImage) withObject:nil afterDelay:0.3];
}</p></li>
<li><p>(void)asyncDisplayHistogramImage {
  NSBlockOperation <em>operation = [NSBlockOperation new];
__weak NSBlockOperation </em>weakOperation = operation;
[operation addExecutionBlock:^{
  if ([weakOperation isCancelled]) {
    return;
  }
  TrafficData <em>data = storeInfo.trafficData;
  UIImage </em>histogramImage = [HistogramTool generateImageForTrafficData:data];
  if (![weakOperation isCancelled] &amp;&amp; data.id == self.trafficData.id) {
    dispatch_async(dispatch_get_main_queue(), ^{
      self.histogramImageView.image = histogramImage;
    });
  }
}];
[self.queue addOperation:operation];
}</p></li>
<li><p>(void)cancelPreviousOperations {
[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(asyncDisplayHistogramImage) object:nil];
[self.queue cancelAllOperations];
}</p></li>
</ul>


<p>// 然后在对于的TableView Delegate中也加上取消操作</p>

<ul>
<li>(void)tableView:(UITableView <em>)tableView didEndDisplayingCell:(UITableViewCell </em>)cell forRowAtIndexPath:(NSIndexPath*)indexPath {
  [cell cancelPreviousOperations];
}</li>
</ul>


<p>```</p>

<p>通过以上一些方法，你将体会到流畅性上很大的提升，当然你还可以考虑加入image cache来再进一步优化。总之这里就是展示了一些UI并发处理的思路，希望抛砖引玉让大家打造出性能卓越的应用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义Navigation Bar样式]]></title>
    <link href="http://sherlockyao.com/blog/2015/04/16/customize-navigation-bar-style/"/>
    <updated>2015-04-16T15:51:00+08:00</updated>
    <id>http://sherlockyao.com/blog/2015/04/16/customize-navigation-bar-style</id>
    <content type="html"><![CDATA[<p>在开发iOS应用时，自定义Navigation Bar样式是非常普遍的一个需求，所以这里特别整理了一些常见的情况，以供快速查阅。照旧先附上参考的原文<a href="http://www.appcoda.com/customize-navigation-status-bar-ios-7/">链接</a>。</p>

<h3>> 更改导航栏背景色</h3>

<p>这个应该是最常见的需求了，同时也只需一行代码就可以实现：</p>

<p>```objc</p>

<p>[[UINavigationBar appearance] setBarTintColor:[UIColor yellowColor]];</p>

<p>```</p>

<h3>> 更改导航栏标题的样式</h3>

<p>有时我们需要修改标题成特殊的字体样式以达到设计上得效果，可以通过设置titleTextAttributes的属性来实现，以下是一些常用的key，同时附上实现代码：</p>

<ul>
<li>UITextAttributeFont – Key to the font</li>
<li>UITextAttributeTextColor – Key to the text color</li>
<li>UITextAttributeTextShadowColor – Key to the text shadow color</li>
<li>UITextAttributeTextShadowOffset – Key to the offset used for the text shadow</li>
</ul>


<p>```objc</p>

<p>NSShadow *shadow = [NSShadow new];
shadow.shadowColor = [UIColor grayColor];
shadow.shadowOffset = CGSizeMake(0, 1);
[[UINavigationBar appearance] setTitleTextAttributes: @{
  NSForegroundColorAttributeName : [UIColor whiteColor],
  NSShadowAttributeName : shadow,
  NSFontAttributeName : [UIFont fontWithName:@&ldquo;HelveticaNeue&rdquo; size:21.0]
}];</p>

<p>```</p>

<p>有些设计会要求使用logo或其他更复杂的内容代替文字显示在标题位置，这个时候我们可以通过设置navigationItem的titleView来实现这些需求，这里以简单地替换成图片为例子：</p>

<p>```objc</p>

<p>// 这里的viewController就是对应的要替换标题的那个view controller，而不是navigation controller本身
viewController.navigationItem.titleView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&ldquo;title&rdquo;]];</p>

<p>```</p>

<h3>> 修改导航栏上按钮的颜色</h3>

<p>我们可以通过设置tintColor来实现，要注意的是，这个颜色会同时影响到所有按钮上的文字和图片：</p>

<p>```objc</p>

<p>[[UINavigationBar appearance] setTintColor:[UIColor whiteColor]];</p>

<p>```</p>

<h3>> 添加更多的导航栏按钮</h3>

<p>这种情况下，我们可以通过设置leftBarButtonItems和rightBarButtonItems来实现，直接给出一段实例代码，大家一看就懂：</p>

<p>```objc</p>

<p>UIBarButtonItem <em>markItem = [UIBarButtonItem barItemWithImage:[UIImage imageNamed:@&ldquo;mark&rdquo;] selectedImage:nil size:CGSizeMake(40, 40) target:self action:@selector(markButtonClicked:)];
UIBarButtonItem </em>starItem = [UIBarButtonItem barItemWithImage:[UIImage imageNamed:@&ldquo;star&rdquo;] selectedImage:[UIImage imageNamed:@&ldquo;star_selected&rdquo;] size:CGSizeMake(30, 40) target:self action:@selector(starButtonClicked:)];
self.navigationItem.rightBarButtonItems = @[starItem, markItem];</p>

<p>```</p>
]]></content>
  </entry>
  
</feed>
